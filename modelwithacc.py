# -*- coding: utf-8 -*-
"""27_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ETh4unav9JIS5WmA4DPMoMbroV9OM31j
"""


import pandas as pd
import numpy as np
#from google.colab import drive
#drive.mount('/content/drive')
# G = pd.read_csv(r'C:\Users\Dell\Downloads\27_New_data_full.csv')
G = pd.read_csv(r'E:\nk\Internship\piyush_fynd-demandforecasting-ebf9ac564e2a\piyush_fynd-demandforecasting-ebf9ac564e2a\New_full_data_27.csv')
import matplotlib.pyplot as plt
import datetime
# convert the datetime column to a datetime type and assign it back to the column
# df_dd.datetime = pd.to_datetime(df_dd.datetime)

G.columns


print(G['Order Date'])
# pd.to_datetime(G['Order Date'])
# P = pd.to_datetime(G['Order Date'], errors='raise', dayfirst=True, yearfirst=False, format=None, exact=True)
# print(len(P))
# print(P)
# G['Order Date'] = P

dat = '1-Apr-22'
q = G['Order Date']
qd = pd.to_datetime(q, dayfirst=True, yearfirst=False, format=None, exact=True) 
p = pd.to_datetime(dat, dayfirst=True, yearfirst=False, format=None, exact=True)
print(dat, p)

G['Order Date'] = qd

G.head()

# G.drop(['0'],inplace = True,axis=1)

G.head(10)

def fill_in_missing_dates(df, date_col_name = 'date',fill_val = 0.1 ,date_format='%Y-%m-%d'):
    df.set_index(date_col_name, drop=True, inplace=True)
    df.index = pd.to_datetime(df.index, format = date_format)
    idx = pd.date_range(df.index.min(), df.index.max())
    print('missing_dates are',idx.difference(df.index))
    df=df.reindex(idx,fill_value=fill_val)
    print('missing_dates after fill',idx.difference(df.index))
    df[date_col_name] = df.index
    df.reset_index(drop=True,inplace=True)
    return df

H = fill_in_missing_dates(G, 'Order Date', 0.0)

H.columns

# # H.head()
# l = ['Day of Order Date', 'AIR CARE', 'AIR CONDITIONER SERVICE', 'AUDIO', 'AUDIO ENHANCEMENT',
#        'CNP IT', 'CNP MOBILITY', 'CONSUMABLES', 'COOKING APPLIANCE SERVICE',
#        'COOKING APPLIANCES', 'DESKTOP', 'DISHWASHER SERVICE',
#        'Delivery Charges', 'ENTERTAINMENT PROMOTION', 'ERECHARGE', 'FANS',
#        'FOOD PRESERVATION', 'GAMING ACCESSORY', 'HARDWARE MOBILITY',
#        'HIGH END TV', 'HOME APPLIANCES PROMOTION', 'HOME AUDIO SERVICE',
#        'HOME CARE SERVICE', 'HOME VISUAL SERVICE', 'LAPTOP', 'LAPTOP SERVICE',
#        'LAUNDRY & WASH CARE', 'LIFESTYLE IT', 'LIFESTYLE MOBILITY', 'LIGHTING',
#        'MEDIAPLAYER', 'MUSICAL INSTRUMENTS (POWERED)',
#        'Mobility (Jio Branded)', 'PERIPHERAL', 'PHOTOGRAPHY',
#        'PHOTOGRAPHY WEARABLE', 'POWER', 'POWER ENTERTAINMENT', 'POWER HA',
#        'PRINTER', 'Printer Services', 'REFRIGERATOR SERVICE',
#        'SMALL DOMESTIC APPL', 'SMART HOME DEVICES', 'SOFTWARE', 'STORAGE',
#        'TABLET', 'TABLET SERVICE', 'TECH ACCESSORIES IT',
#        'TECH ACCESSORIES MOBILITY', 'TELECOM SERVICE', 'WASHER SERVICE',
#        'WEARABLE DEVICE', 'WEARABLES SERVICE', 'WIRELESS PHONE',
#        'WIRELESS PHONE SERVICE', 'BIG BAZAAR-PROD', 'DC / STORE CONSUMABLES',
#        'DRYER SERVICE', 'GAMING SOFTWARE', 'HARDWARE HA']

l = [ 'Order Date', 'AIR CARE', 'AIR CONDITIONER SERVICE', 'AUDIO', 'AUDIO ENHANCEMENT',
       'CNP IT', 'CNP MOBILITY', 'CONSUMABLES', 'COOKING APPLIANCES',
       'DC / STORE CONSUMABLES', 'DESKTOP', 'DISHWASHER SERVICE',
       'ENTERTAINMENT PROMOTION', 'ERECHARGE', 'FANS', 'FOOD PRESERVATION',
       'GAMING ACCESSORY', 'HARDWARE HA', 'HARDWARE MOBILITY', 'HIGH END TV',
       'HOME APPLIANCES PROMOTION', 'HOME AUDIO SERVICE', 'HOME CARE SERVICE',
       'HOME VISUAL SERVICE', 'LAPTOP', 'LAUNDRY & WASH CARE', 'LIFESTYLE IT',
       'LIFESTYLE MOBILITY', 'LIGHTING', 'MEDIAPLAYER',
       'MUSICAL INSTRUMENTS (POWERED)', 'Mobility (Jio Branded)', 'PERIPHERAL',
       'PHOTOGRAPHY', 'PHOTOGRAPHY WEARABLE', 'POWER', 'POWER ENTERTAINMENT',
       'POWER HA', 'PRINTER', 'Printer Services', 'REFRIGERATOR SERVICE',
       'SMALL DOMESTIC APPL', 'SMART HOME DEVICES', 'SOFTWARE', 'STORAGE',
       'TABLET', 'TABLET SERVICE', 'TECH ACCESSORIES IT',
       'TECH ACCESSORIES MOBILITY', 'TELECOM SERVICE', 'WASHER SERVICE',
       'WEARABLE DEVICE', 'WEARABLES SERVICE', 'WIRELESS PHONE',
       'WIRELESS PHONE SERVICE']

T = H[l]
T.head(40)

T.columns

G = T

G.head()

Products = list(G.columns)
# Products.remove('Order Date')

G.columns

G.Datetime = pd.to_datetime(G['Order Date'])

G.sort_values(by='Order Date')
G.head(5)

print(G['Order Date'].min())
print(G['Order Date'].max())

G.fillna(0.0, inplace=True)

def accuracy(family_type):
    # F : new data frame which will store a category which is to be predicted
    F = pd.DataFrame()

    F[family_type] = G[family_type]

    # F[family_type] = np.sqrt(F[family_type])

    F['date'] = G['Order Date']

    F.sort_values(by='date')
    F = F.set_index('date')

    y = F[family_type]

    import statsmodels.api as sm
    import pandas.util.testing as tm
    decomposition = sm.tsa.seasonal_decompose(y, model='additive')

    p = d = q = range(0, 2)
    import itertools
    pdq = list(itertools.product(p, d, q))
    s_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]

    import warnings
    warnings.filterwarnings("ignore")
    from statsmodels.tsa.arima_model import ARIMA

    pdq_results = []

    for param in pdq:
        for param_seasonal in s_pdq:
            try:
                model = sm.tsa.statespace.SARIMAX(y, order=param, seasonal_order=param_seasonal, enforce_stationarity=False, enforce_invertibility=False) 
                results = model.fit() 
                # print(results.aic, param, param_seasonal)
                pdq_results.append([results.aic, param, param_seasonal])
            except:
                continue

    pdq_results.sort()
    # print(pdq_results)
    # print(pdq_results[0])

    p1 = pdq_results[0][1]
    p2 = pdq_results[0][2]

    # print(p1, p2)

    Data_to_fed = y['2021-10-06':'2022-03-31']

    ########################################################################################################################

    Model = sm.tsa.statespace.SARIMAX(Data_to_fed, order=p1, seasonal_order=p2, enforce_stationarity=False, enforce_invertibility=False)
    # Model = sm.tsa.statespace.SARIMAX(Data_to_fed, order=p1, seasonal_order=p2)
    Results = model.fit()

    import datetime as dt

    Pred = Results.get_prediction(start='2022-04-01', end='2022-05-29', dynamic=False)
    # 022-05-29 00:00:00
    pred_ci = Pred.conf_int()

    y_forecasted = Pred.predicted_mean
    y_original = y['2022-04-01':'2022-05-29']

    n = len(y_forecasted)

    maps = 0.0
    for i in range(0, n):
        maps += abs(y_forecasted[i] - y_original[i])**2
    
    k = 0
    for i in range(0, n):
        k += (y_original[i])**2
    
    print(family_type, maps, k)
    
    nn = float(maps)
    dd = float(k)

    return maps/k

G.head(5)
G.to_csv("New_full_data_27.csv")

abs_diff_sum = []
Family_members = ['AIR CARE', 'AIR CONDITIONER SERVICE', 'AUDIO',
       'AUDIO ENHANCEMENT', 'CNP IT', 'CNP MOBILITY', 'CONSUMABLES',
       'COOKING APPLIANCES', 'DC / STORE CONSUMABLES', 'DESKTOP',
       'DISHWASHER SERVICE', 'ENTERTAINMENT PROMOTION', 'ERECHARGE', 'FANS',
       'FOOD PRESERVATION', 'GAMING ACCESSORY', 'HARDWARE HA',
       'HARDWARE MOBILITY', 'HIGH END TV', 'HOME APPLIANCES PROMOTION',
       'HOME AUDIO SERVICE', 'HOME CARE SERVICE', 'HOME VISUAL SERVICE',
       'LAPTOP', 'LAUNDRY & WASH CARE', 'LIFESTYLE IT', 'LIFESTYLE MOBILITY',
       'LIGHTING', 'MEDIAPLAYER', 'MUSICAL INSTRUMENTS (POWERED)',
       'Mobility (Jio Branded)', 'PERIPHERAL', 'PHOTOGRAPHY',
       'PHOTOGRAPHY WEARABLE', 'POWER', 'POWER ENTERTAINMENT', 'POWER HA',
       'PRINTER', 'Printer Services', 'REFRIGERATOR SERVICE',
       'SMALL DOMESTIC APPL', 'SMART HOME DEVICES', 'SOFTWARE', 'STORAGE',
       'TABLET', 'TABLET SERVICE', 'TECH ACCESSORIES IT',
       'TECH ACCESSORIES MOBILITY', 'TELECOM SERVICE', 'WASHER SERVICE',
       'WEARABLE DEVICE', 'WEARABLES SERVICE', 'WIRELESS PHONE',
       'WIRELESS PHONE SERVICE']

D = dict()
for i in range(len(Family_members)):
    D[Family_members[i]] = str(i)
print(D)


l = []
print(len(Family_members))
for i in range(0, len(Family_members)):
    print(i, end=',')
    l.append(accuracy(Family_members[i]))

# # print("Accuacy :", A/p)

# AIR CARE 245971079.6841788 448007205.62
# 1,AIR CONDITIONER SERVICE 428616.1337800569 527945.0
# 2,AUDIO 5604397.959401044 8863951.440000001
# 3,AUDIO ENHANCEMENT 88982839.32424891 134778906.18
# 4,CNP IT 1465.1818976965224 399.0
# 5,CNP MOBILITY 3545.6372352791072 698.0
# 6,CONSUMABLES 98439.41725461677 96653.0
# 7,COOKING APPLIANCES 1373572.1321917025 1513939.0
# 8,DC / STORE CONSUMABLES 759.6064631089433 444.0
# 9,DESKTOP 1254684.3606889462 1107773.0
# 10,DISHWASHER SERVICE 4.0420441474019455 1.2
# 11,ENTERTAINMENT PROMOTION 47895.55888563373 24599.0
# 12,ERECHARGE 226433.4676988334 97825.0
# 13,FANS 491562.8445468173 769613.0
# 14,FOOD PRESERVATION 72139766.26259159 145967039.0
# 15,GAMING ACCESSORY 207584.1120820362 89754.0
# 16,HARDWARE HA 22287.229298911574 14985.0
# 17,HARDWARE MOBILITY 771738.8306520066 957699.0
# 18,HIGH END TV 117720613.15735036 224679218.56
# 19,HOME APPLIANCES PROMOTION 17711.547719317787 5999.0
# 20,HOME AUDIO SERVICE 47.25121819412728 28.799999999999997
# 21,HOME CARE SERVICE 4493.9117288729985 302.4
# 22,HOME VISUAL SERVICE 6116.184460159314 6554.399999999998
# 23,LAPTOP 37409681.07379594 68937074.0
# 24,LAUNDRY & WASH CARE 23712428.949774798 46113359.0
# 25,LIFESTYLE IT 63356.31369350834 44978.0
# 26,LIFESTYLE MOBILITY 35943.64887420709 17798.0
# 27,LIGHTING 98162.32767692865 112208.0
# 28,MEDIAPLAYER 193395.78791811172 173972.0
# 29,MUSICAL INSTRUMENTS (POWERED) 22285.126024162026 7591.0
# 30,Mobility (Jio Branded) 2595337.233098808 1013922.0
# 31,PERIPHERAL 1815104.0614676673 3162083.0
# 32,PHOTOGRAPHY 5810891.619743087 6439646.0
# 33,PHOTOGRAPHY WEARABLE 25217.02637525195 3999.0
# 34,POWER 14689262.325839449 20584837.0
# 35,POWER ENTERTAINMENT 216158.27433981735 180969.0
# 36,POWER HA 133802.36583071403 114526.0
# 37,PRINTER 6291010.327466238 10738704.0
# 38,Printer Services 281.8788967010111 0.0
# 39,REFRIGERATOR SERVICE 51937.672104176476 59132.6
# 40,SMALL DOMESTIC APPL 46083664.76317599 101493499.0
# 41,SMART HOME DEVICES 448413.6980486743 754433.0
# 42,SOFTWARE 3379.388884836728 0.0
# 43,STORAGE 10237976.635832943 22645791.0
# 44,TABLET 12170420.987639507 18175676.0
# 45,TABLET SERVICE 460.492460741192 0.0
# 46,TECH ACCESSORIES IT 151954.80914447497 210943.0
# 47,TECH ACCESSORIES MOBILITY 623223.6426826619 1009483.0
# 48,TELECOM SERVICE 10.068591779164485 0.0
# 49,WASHER SERVICE 29326.748549479536 29871.4
# 50,WEARABLE DEVICE 21774705.535440553 28734302.0
# 51,WEARABLES SERVICE 2138.081598769025 0.0
# 52,WIRELESS PHONE 852900358.9457103 1464765959.38
# 53,WIRELESS PHONE SERVICE 82519.59380235763 47970.0

# print(abs_diff)
print(l)
# q = [2.0, 0.0, 0.0, 80.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 6.0, 2.0, 0.0, 0.0, 6.0, 6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 9.0, 1.0, 0.0, 7.0, 0.0, 0.0, 0.0, 0.0, 0.0, 23.0, 0.0, 0.0, 13.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 6.0, 0.0, 34.0, 0.0]
# print(len(q))
# print(np.mean(q)*100)

# q = [0.2659315059922711, 0.4670802088258841, 0.3732217912424134, 0.41470894773977923, 1.4387126005406177, 1.6992454124840366, 0.5549854329651304, 0.5762842784220573, 1.0139962489518193, 0.5686766575041563, 1.2259066855110654, 0.9673573502312125, 1.1232207277103419, 0.34879758273746975, 0.23427357320736555, 1.0787164732946357, 0.7992518192699981, 0.6177496314094654, 0.27265544039072975, 1.1461363204558523, 0.862408032364733, 205.52659322375632, 0.6837285395642704, 0.22579025370452396, 0.26200685538019264, 0.8332226577534091, 1.051308675271711, 0.4614661021830544, 0.7828617100731405, 1.1720455198143827, 2.8118032159253414, 0.3488237343647039, 0.5488772035461744, 2.4532766180547636, 0.4541817555303893, 0.7197758815275762, 0.8074939989123224, 0.2883070334131747, inf, 0.5310314201981154, 0.23037933984615155, 0.3456216708736661, inf, 0.2304476129633403, 0.37257766560887323, inf, 0.31185894693226585, 0.40802988391220246, inf, 0.5195934995404418, 0.46515213213006046, inf, 0.250669752414635, 1.01158882976237]
q = []
print(len(q))
for i in l:
    j = str(round((1.00 - round(i, 4))*100, 2))
    if(str(i)=='inf' or i>1.00):
        j = '1.00'
    q.append(j)

print(q)



def Prediction_Function(family_type, date_to_be_forecasted):
    # F : new data frame which will store a category which is to be predicted
    F = pd.DataFrame()

    F[family_type] = G[family_type]

    # F[family_type] = np.sqrt(F[family_type])

    F['date'] = G['Order Date']

    F.sort_values(by='date')
    F = F.set_index('date')

    y = F[family_type]
    # y.plot(figsize=(15, 6))
    # plt.show()
    # print("PLOT FOR THE DATA")

    ########################################################################################################################

    import statsmodels.api as sm
    import pandas.util.testing as tm
    decomposition = sm.tsa.seasonal_decompose(y, model='additive')

    # fig = decomposition.plot()

    # plt.figure(figsize=(18,8))
    # plt.show()
    # print("Decomposition into various components like seasonality, skewdness")


    ########################################################################################################################

    # Arima (Auto Regressive Integrated Moving Average) : 

    # p : AR term
    # d : MA term
    # q : # of differencing required to make the data series stationary

    # if it has seasonal patterns then S-arima

    p = d = q = range(0, 2)
    import itertools
    pdq = list(itertools.product(p, d, q))
    s_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]


    # print('Examples of parameter combinations for Seasonal ARIMA...')
    # print('SARIMAX: {} x {}'.format(pdq[1], s_pdq[1]))
    # print('SARIMAX: {} x {}'.format(pdq[1], s_pdq[2]))
    # print('SARIMAX: {} x {}'.format(pdq[2], s_pdq[3]))
    # print('SARIMAX: {} x {}'.format(pdq[2], s_pdq[4]))

    import warnings
    warnings.filterwarnings("ignore")
    from statsmodels.tsa.arima_model import ARIMA

    # print(pdq)
    # print(s_pdq)

    ########################################################################################################################

    pdq_results = []

    for param in pdq:
        for param_seasonal in s_pdq:
            try:
                model = sm.tsa.statespace.SARIMAX(y, order=param, seasonal_order=param_seasonal, enforce_stationarity=False, enforce_invertibility=False) 
                results = model.fit() 
                # print(results.aic, param, param_seasonal)
                pdq_results.append([results.aic, param, param_seasonal])
            except:
                continue

    pdq_results.sort()
    # print(pdq_results)
    # print(pdq_results[0])

    p1 = pdq_results[0][1]
    p2 = pdq_results[0][2]

    # print(p1, p2)

    Data_to_fed = y['2021-10-06':]

    ########################################################################################################################

    Model = sm.tsa.statespace.SARIMAX(Data_to_fed, order=p1, seasonal_order=p2, enforce_stationarity=False, enforce_invertibility=False)
    # Model = sm.tsa.statespace.SARIMAX(Data_to_fed, order=p1, seasonal_order=p2)
    Results = model.fit()
    
    ########################################################################################################################

    # print(Results.summary().tables[0])
    # print(Results.summary().tables[1])
    # print(Results.summary().tables[2])


    ########################################################################################################################
    # I am seeing that the data is too peaked in the middle seeing by qq plot
    # Rectification : may use log 
    
    ########################################################################################################################

    # Model Diagostics
    # Results.plot_diagnostics(figsize=(16, 8))
    # Results.plot_diagnostics(figsize=(16, 8), lags = 15) # Number of lags to include in the correlogram. Default is 10.
    
    # plt.show()
    # print()

    #prediction 
    import datetime as dt

    #get predictions starting from the min date and calculate confidence intervals

    # Pred = Results.get_prediction(start=dt.datetime(2022, 5, 9), dynamic=False)
    Pred = Results.get_prediction(start='2021-10-06', dynamic=False)
    # Pred = Results.get_prediction(start='2022-08-09', dynamic=False)
    pred_ci = Pred.conf_int()

    # Methods
    # conf_int([alpha]) : Confidence interval construction for the predicted mean.
    # summary_frame([alpha]) : Summary frame of mean, variance and confidence interval.
    # t_test([value, alternative]) : z- or t-test for hypothesis that mean is equal to value

    # Properties
    # predicted_mean : The predicted mean 
    # row_labels : The row labels used in pandas-types.
    # se_mean : The standard deviation of the predicted mean
    # tvalues : The ratio of the predicted mean to its standard deviation
    # var_pred_mean : The variance of the predicted mean

    ########################################################################################################################

    # X_data = y['2021-08-09':].plot(label='Observed')

    # Pred.predicted_mean.plot(ax=X_data, label='One-step ahead Forecast', alpha=.7, figsize=(14, 7))

    # X_data.fill_between(pred_ci.index, pred_ci.iloc[:, 0], pred_ci.iloc[:, 1], color='k', alpha=.2)

    # X_data.set_xlabel('Date')
    # X_data.set_ylabel(family_type)

    # plt.show()
    # print()

    ########################################################################################################################

    y_forecasted = Pred.predicted_mean
    y_original = y['2021-10-06':]

    Mean_square_error = ((y_forecasted - y_original)**2).mean()

    # print(round(Mean_square_error, 4))
    MSE = Mean_square_error

    RMSE = MSE**0.5

    # print(family_type, "MSE :", MSE, "RMSE :", round(RMSE, 4))

    ########################################################################################################################
    # Further Prediction
    ########################################################################################################################

    # Pred_uc = Pred
    # pred_uc = results.get_forecast(steps=100) # steps 
    # pred_ci = pred_uc.conf_int() # for construction of the interval [ which shows future predicted values ]


    # # X_data = y.plot(label='Observed', figsize=(14, 7))

    # pred_uc.predicted_mean.plot(ax=X_data, label='Forecasting data values')

    # pred_dynamic = results.get_prediction(start='2022-01-01',dynamic=False, full_results=False)
    # pred_dynamic_ci = pred_dynamic.conf_int()


    # ax = y['2022':].plot(label='_Observed_')
    # pred_dynamic.predicted_mean.plot(ax=ax, label='Forecast', figsize=(20, 12), alpha=.7)

    # ax.fill_between(pred_ci.index, pred_ci.iloc[:, 0], pred_ci.iloc[:, 1], color='k', alpha=.2)

    # ax.set_xlabel('date')
    # ax.set_ylabel(family_type)

    # # plt.legend()
    # # plt.show()
    # # print()

    # # Future prediction and seasonality

    # pred_dynamic = results.get_forecast(steps=111)
    # pred_ci = pred_uc.conf_int()

    # # ax = y.plot(label='Observed', figsize=(20, 12))

    # pred_dynamic.predicted_mean.plot(ax=ax, label='Forecast')

    # ax.fill_between(pred_ci.index, pred_ci.iloc[:, 0], pred_ci.iloc[:, 1], color='k', alpha=.25)

    # ax.set_xlabel('date')
    # ax.set_ylabel(family_type)

    # # plt.legend()
    # # plt.show()
    # # print()

    Forecast = Results.predict(start=date_to_be_forecasted, end = date_to_be_forecasted)

    Value = int(abs(Forecast[0]))

    Family_members = ['AIR CARE', 'AIR CONDITIONER SERVICE', 'AUDIO',
       'AUDIO ENHANCEMENT', 'CNP IT', 'CNP MOBILITY', 'CONSUMABLES',
       'COOKING APPLIANCES', 'DC / STORE CONSUMABLES', 'DESKTOP',
       'DISHWASHER SERVICE', 'ENTERTAINMENT PROMOTION', 'ERECHARGE', 'FANS',
       'FOOD PRESERVATION', 'GAMING ACCESSORY', 'HARDWARE HA',
       'HARDWARE MOBILITY', 'HIGH END TV', 'HOME APPLIANCES PROMOTION',
       'HOME AUDIO SERVICE', 'HOME CARE SERVICE', 'HOME VISUAL SERVICE',
       'LAPTOP', 'LAUNDRY & WASH CARE', 'LIFESTYLE IT', 'LIFESTYLE MOBILITY',
       'LIGHTING', 'MEDIAPLAYER', 'MUSICAL INSTRUMENTS (POWERED)',
       'Mobility (Jio Branded)', 'PERIPHERAL', 'PHOTOGRAPHY',
       'PHOTOGRAPHY WEARABLE', 'POWER', 'POWER ENTERTAINMENT', 'POWER HA',
       'PRINTER', 'Printer Services', 'REFRIGERATOR SERVICE',
       'SMALL DOMESTIC APPL', 'SMART HOME DEVICES', 'SOFTWARE', 'STORAGE',
       'TABLET', 'TABLET SERVICE', 'TECH ACCESSORIES IT',
       'TECH ACCESSORIES MOBILITY', 'TELECOM SERVICE', 'WASHER SERVICE',
       'WEARABLE DEVICE', 'WEARABLES SERVICE', 'WIRELESS PHONE',
       'WIRELESS PHONE SERVICE']
    id = 0;
    aq = ['73.41', '53.29', '62.68', '58.53', '1.00', '1.00', '44.5', '42.37', '1.00', '43.13', '1.00', '3.26', '1.00', '65.12', '76.57', '1.00', '20.07', '38.23', '72.73', '1.00', '13.76', '1.00', '31.63', '77.42', '73.8', '16.68', '1.00', '53.85', '21.71', '1.00', '1.00', '65.12', '45.11', '1.00', '54.58', '28.02', '19.25', '71.17', '1.00', '46.9', '76.96', '65.44', '1.00', '76.96', '62.74', '1.00', '68.81', '59.2', '1.00', '48.04', '53.48', '1.00', '74.93', '1.00']
    for i in range(len(aq)):
        if(Family_members[i]==family_type):
            id = i;
            break;

    # id = int(D[family_type])

    ac = str(Value)
    ac = ac + " , Accuracy = "
    ac = ac + aq[id]

    # ac = str(Value) + " , Accuracy = " + q[id];
    # print("AC:", ac)
    return ac

date_to_be_forecasted = "2029-06-01"
family = 'FANS'
Value = Prediction_Function(family, date_to_be_forecasted)
print(Value)

# id = int(D[family])
# print(id)
# print(q[id])
# st = str('Orders = ' + str(Value) + ', Accuracy = ' + str(q[id]))
# print(st)



